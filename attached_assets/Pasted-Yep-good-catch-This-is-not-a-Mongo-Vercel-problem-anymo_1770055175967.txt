Yep â€” good catch. This is not a Mongo/Vercel problem anymore. This is onboarding state logic doing exactly what you told it to doâ€¦ just a little too aggressively ğŸ˜…
Letâ€™s break it cleanly and fix it surgically.


---

ğŸ§  Whatâ€™s actually happening (clear diagnosis)

The flow youâ€™re seeing:

1. User answers onboarding questions


2. Final phase submits


3. Backend fails validation OR doesnâ€™t mark completion


4. Frontend falls back to question 1


5. Retry counter increments


6. Rate limiter trips â†’
â€œToo many attempts. Try again in 5 minutes.â€



ğŸ‘‰ This means:

Mongo is working

Writes are partially succeeding

But completion state is never committed



---

ğŸ”¥ The real root cause (99% certainty)

One (or more) of these is true in /api/onboarding/quiz:

âŒ Missing atomic completion write

You likely have logic like:

user.onboardingStep = nextStep;
await user.save();

â€¦but never:

user.onboardingCompleted = true;

or never persist:

user.onboardingVersion = CURRENT_VERSION;

So when the app reloads:

if (!user.onboardingCompleted) â†’ restart onboarding


---

âŒ Validation mismatch on final phase

Common bug:

Final phase expects fields that earlier phases didnâ€™t provide

Or expects AI-evaluated output that failed silently


Example:

if (!quizResult.confidenceScore) throw Error()

But you still increment attempt count before throwing.


---

âŒ Rate limit increments on logical failure

Your rate limiter is probably counting any POST, not only failures that matter.

So even a logic reset counts as an â€œattemptâ€.


---

ğŸ§¯ Why Mongo â€œworks but onboarding doesnâ€™tâ€

Because this is business logic, not infrastructure:

Layer	Status

MongoDB connection	âœ…
Write permissions	âœ…
API route	âœ…
Onboarding completion flag	âŒ
Retry logic	âŒ Over-eager



---

âœ… The exact fixes (do these in order)

1ï¸âƒ£ Add an explicit completion flag (non-negotiable)

In your User schema:

onboarding: {
  completed: { type: Boolean, default: false },
  step: { type: Number, default: 0 },
  completedAt: Date,
}


---

2ï¸âƒ£ Final phase MUST do this atomically

In /api/onboarding/quiz (final step only):

await User.updateOne(
  { _id: userId },
  {
    $set: {
      "onboarding.completed": true,
      "onboarding.step": FINAL_STEP,
      "onboarding.completedAt": new Date(),
    }
  }
);

âš ï¸ Do not rely on frontend state to infer completion.


---

3ï¸âƒ£ Frontend guard (this stops the reset)

Wherever onboarding loads:

if (user.onboarding?.completed) {
  router.replace("/dashboard");
  return;
}

This prevents any fallback to question 1.


---

4ï¸âƒ£ Fix the rate limiter (important)

Only increment attempts on real failures:

if (validationError || authError) {
  incrementAttempts();
}

Do not increment when:

Step advances

Step resets

Completion succeeds


Also reset attempts on completion:

attempts = 0;


---

ğŸ§ª Quick debug check (2 minutes)

Add this log temporarily in final phase:

console.log("ONBOARDING FINAL WRITE", {
  userId,
  completed: true
});

If you donâ€™t see it â†’ final phase never fires
If you see it but onboarding restarts â†’ frontend guard missing


---

ğŸŸ¢ Why this is actually good news

This means:

Your security model works

Abuse prevention works

Mongo is stable

State persistence is almost right


Youâ€™re not broken â€” youâ€™re one boolean away from done.


---

ğŸš€ Next after fix

Once onboarding completes correctly:

Products unlock

Orders activate

Disputes become usable

Admin dashboard becomes reachable

Rate limiter becomes invisible



---

If you want:

Paste just your /api/onboarding/quiz handler (no secrets),
and Iâ€™ll point to the exact line causing the reset.

Youâ€™re very close.