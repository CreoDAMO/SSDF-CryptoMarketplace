Perfect â€” thank you for confirming. Since you already applied the client-side fix and itâ€™s still looping, this tells us something very specific and very important:

> âš ï¸ This is no longer a client refresh problem.
This is a SERVER-SIDE GUARD that is re-routing before the client ever gets control.



Youâ€™re dealing with a middleware or server layout redirect, not a stale client session.

This is the last onboarding trap in App Router + Clerk setups. Letâ€™s kill it cleanly.


---

ğŸ” Whatâ€™s ACTUALLY Happening (Authoritative)

Your flow right now:

1. User clicks Confirm


2. /api/onboarding/complete returns 200 âœ…


3. Router tries to navigate to /dashboard


4. Before the page renders, one of these runs:

middleware.ts

a server layout.tsx

a server page.tsx



5. That server code checks onboarding state


6. It still thinks onboarding is incomplete


7. It redirects you back to /onboarding/completion


8. Client never gets a chance to update



Thatâ€™s why no client-side fix can solve this.


---

ğŸ¯ The Smoking Gun (99% Certainty)

You have ONE of these patterns somewhere:

1ï¸âƒ£ Middleware (most common)

// middleware.ts
if (!user?.publicMetadata?.onboardingComplete) {
  return NextResponse.redirect('/onboarding/completion');
}

2ï¸âƒ£ Server layout guard

// app/(protected)/layout.tsx
if (!user.publicMetadata.onboardingComplete) {
  redirect('/onboarding/completion');
}

3ï¸âƒ£ Server page guard

// app/dashboard/page.tsx
if (!user.publicMetadata.onboardingComplete) {
  redirect('/onboarding/completion');
}

And that code is executing BEFORE Clerk metadata has propagated.

Clerk metadata propagation is eventual, not immediate.


---

âœ… The REAL Fix (Production-Grade, No Guessing)

ğŸ”‘ Rule

Never gate onboarding completion on publicMetadata alone on the server.

You must use a DB-backed source of truth or a one-time bypass flag.


---

âœ… Correct Pattern (Minimal Change, No Re-architecture)

Step 1: Add a DB onboarding flag (you already have Mongo)

In your User or Account model:

onboardingComplete: boolean;

Set this inside /api/onboarding/complete:

await User.updateOne(
  { clerkId: userId },
  { onboardingComplete: true },
  { upsert: true }
);


---

Step 2: Change ALL server guards to use DB state

âŒ DO NOT DO THIS

if (!user.publicMetadata.onboardingComplete) redirect(...)

âœ… DO THIS

const dbUser = await User.findOne({ clerkId: userId });

if (!dbUser?.onboardingComplete) {
  redirect('/onboarding/completion');
}

This removes Clerk propagation timing entirely.


---

âš¡ Emergency Hotfix (If You Want Zero DB Changes)

If you want the fastest possible unblock, do this instead:

ğŸ”¥ Allow completion page to bypass guard once

In middleware.ts (or layout):

if (pathname === '/onboarding/completion') {
  return NextResponse.next();
}

AND only redirect if NOT navigating away from onboarding.

This prevents the self-loop.


---

ğŸ§ª How to Confirm Which Guard Is Doing This

Add a log in middleware.ts:

console.log('MIDDLEWARE HIT', pathname);

If you see logs when clicking Confirm â†’ thatâ€™s the culprit.


---

ğŸ§  Why This Is Subtle (And Why You Did Nothing Wrong)

Clerk metadata writes are async

App Router guards run before hydration

Middleware runs before everything

Client fixes cannot override server redirects


This is a classic senior-level Next.js trap, not a mistake.


---

âœ… Final Recommendation (Best Practice)

Layer	Purpose

Clerk metadata	UX + roles
MongoDB	Authoritative onboarding state
Middleware	Only auth, never onboarding completion
Layout/page guards	DB-backed only



---

What I Need From You (One Thing)

Paste ONE file:

middleware.ts OR

the layout/page where onboarding redirect happens


Iâ€™ll mark the exact 3 lines to change and youâ€™ll be done â€” permanently.